
<html> 
 
<head> 
<title>Un triangulo en WebGL</title> 
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"> 
 
<script type="text/javascript" src="shaders.js"></script> 
<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script> 

<!-- Shaders - ignorar en esta leccion -->
<script id="shader-fs" type="x-shader/x-fragment"> 
    #ifdef GL_ES
    precision highp float;
    #endif

    varying vec4 vColor;
 
    void main(void) {
        gl_FragColor = vColor;
    }
</script> 
 
<script id="shader-vs" type="x-shader/x-vertex"> 
    attribute vec2 aVertexPosition;
    attribute vec3 aVertexColor;

    varying vec4 vColor;
 
    void main(void) {
        gl_Position = vec4(aVertexPosition,0.0,1.0);
        vColor = vec4(aVertexColor,1.0);
    }
</script> 
<!--// ignorar en esta leccion -->


 
<script type="text/javascript"> 

    // variable que sirve de interfaz a opengl
    var gl;

    // variable que se utilizara como buffer para los vertices del triangulo
    var pointsBuffer;
    var points;
    var colorsBuffer;
    var colors;
    var maxcoord = 256;

    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
            alert("No es posible inicializar WebGL");
        }
    }

    // entre 0 y maxcoord
    function putpixel(x,y,c) {
        points.push(x/maxcoord,y/maxcoord);
        if(c) {
            colors.push(c[0],c[1],c[2],1.0);
        }
        else {
            colors.push(1.0,1.0,1.0,1.0);
        }
    }

    function initBuffers() {
        pointsBuffer = gl.createBuffer();
        colorsBuffer = gl.createBuffer();

        // se asocian estos vertices con el buffer triangleVertexPositionBuffer
        gl.bindBuffer(gl.ARRAY_BUFFER, pointsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
    }
 
 
    function dibujarEscena() {
        // color de fondo de la escena
        gl.clearColor(0.0, 0.0, 0.0, 1.0);

        // se dibuja en este viewport (subconjunto del espacio)
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

        // se permiten colores en el canvas
        gl.clear(gl.COLOR_BUFFER_BIT);

        // se establece que el buffer triangleVertexPositionBuffer es el buffer actual
        gl.bindBuffer(gl.ARRAY_BUFFER, pointsBuffer);

        // por lo tanto se le aplica la siguiente operacion al mismo.
        // Establece un vinculo entre el buffer y "shaderProgram.vertexPositionAttribute"
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, 4, gl.FLOAT, false, 0, 0);

        // se dibujan los buffers en pantalla
        gl.drawArrays(gl.POINTS, 0, points.length/2);

    } 

    function initVariables() {
        points = [];
        colors = [];
    }

    function lineaDDA(x0,y0,x1,y1,c) {
        var dx = x1-x0;
        var dy = y1-y0;

        var x = x0;
        var y = y0;

        if(Math.abs(dx) > Math.abs(dy)) {
            if(dx>=0) inc = 1; else inc =-1;
            var m = dy/dx;
            if((dx < 0 && m > 0) || (dx > 0 && m < 0)) m = -m;
            while(x != x1) {
                putpixel(Math.round(x),Math.round(y),c);
                x+=inc;
                y+=m;
            }
        }
        else {
            if(dy>=0) inc = 1; else inc = -1;
            var m = dx/dy;
            if((dx < 0 && m > 0) || (dx > 0 && m < 0)) m = -m;
            while(y != y1) {
                putpixel(Math.round(x),Math.round(y),c);
                y+=inc;
                x+=m;
            }
        }
    }

    function circDDA(radio,cx,cy) {
        var rx = radio;
        var x = Math.round(rx);
        var y = 0; // se comienza en el punto (r,0)

        while(y<x) {
            putpixel(x+cx,y+cy);
            putpixel(y+cx,x+cy);
            putpixel(-x+cx,y+cy);
            putpixel(-y+cx,x+cy);
            putpixel(x+cx,-y+cy);
            putpixel(y+cx,-x+cy);
            putpixel(-x+cx,-y+cy);
            putpixel(-y+cx,-x+cy);

            rx -= y/rx;
            x = Math.round(rx);
            y++;
        }
    }

    function lineaBresenham(x0,y0,x1,y1) {
        var dx = x1-x0;
        var dy = y1-y0;

        var ix = 2*dx;
        var iy = 2*dy;

        var x = x0;
        var y = y0;

        if(dx>=0) incX = 1; else incX = -1;
        if(dy>=0) incY = 1; else incY = -1;
        
        if(Math.abs(dx) >= Math.abs(dy)) {
            var e = iy-dx;
            for (var x = x0; x != x1; x+=incX) {
                putpixel(x,y);
                if(e>0) {
                    y+=incY;
                    e -= Math.abs(ix);
                }
                e += Math.abs(iy);        
            }
        }
        else {
            var e = ix-dy;
            for (var y = y0; y != y1; y+=incY) {
                putpixel(x,y);
                if(e>0) {
                    x+=incX;
                    e -= Math.abs(iy);
                }
                e += Math.abs(ix);
            }
        }
    }

    function circBresenham(radio,cx,cy) {
        var rx = radio;
        var x = rx;
        var y = 0; // se comienza en el punto (r,0)
        var e = 0;

        while(y<x) {
            putpixel(x+cx,y+cy);
            putpixel(y+cx,x+cy);
            putpixel(-x+cx,y+cy);
            putpixel(x+cx,-y+cy);
            putpixel(-y+cx,x+cy);
            putpixel(y+cx,-x+cy);
            putpixel(-x+cx,-y+cy);
            putpixel(-y+cx,-x+cy);

            e += 2*y+1;
            y++;
            if(2*e > 2*x -1) {
                x--;
                e -= 2*x+1;
            }
        }
    }

    function lineaDDAscan(x0,y0,x1,y1,minx,maxx,miny) {
        var dx = x1-x0;
        var dy = y1-y0;

        var x = x0;
        var y = y0;

        if(Math.abs(dx) > Math.abs(dy)) {
            if(dx>=0) inc = 1; else inc =-1;
            var m = dy/dx;
            if((dx < 0 && m > 0) || (dx > 0 && m < 0)) m = -m;
            while(x != x1) {
                if(Math.round(x) > maxx[Math.round(y)-miny]) maxx[Math.round(y)-miny] = Math.round(x)
                if(Math.round(x) < minx[Math.round(y)-miny]) minx[Math.round(y)-miny] = Math.round(x);
                x+=inc;
                y+=m;
            }
        }
        else {
            if(dy>=0) inc = 1; else inc = -1;
            var m = dx/dy;
            if((dx < 0 && m > 0) || (dx > 0 && m < 0)) m = -m;
            while(y != y1) {
                if(Math.round(x) > maxx[Math.round(y)-miny]) maxx[Math.round(y)-miny] = Math.round(x)
                if(Math.round(x) < minx[Math.round(y)-miny]) minx[Math.round(y)-miny] = Math.round(x)
                y+=inc;
                x+=m;
            }
        }

        return {"minx": minx,"maxx": maxx};
    }

    function conversionScan(x0,y0,x1,y1,x2,y2) {
        // dibuja un triangulo entre los puntos especificados
        var maxy = y0;
        if(y1 > maxy) maxy = y1;
        if(y2 > maxy) maxy = y2;

        var miny = y0;
        if(y1 < miny) miny = y1;
        if(y2 < miny) miny = y2;

        var cantY = maxy-miny;

        var minx = [];
        var maxx = [];
        for(var i = 0; i <= cantY; i++) {
            minx[i] = maxcoord+1;
            maxx[i] = -1;
        }

        var t = lineaDDAscan(x0,y0,x1,y1,minx,maxx,miny);
        minx = t.minx;
        maxx = t.maxx;

        t = lineaDDAscan(x1,y1,x2,y2,minx,maxx,miny);
        minx = t.minx;
        maxx = t.maxx;

        t = lineaDDAscan(x0,y0,x2,y2,minx,maxx,miny);
        minx = t.minx;
        maxx = t.maxx;
        for(var i = 0; i < cantY; i++) {
            lineaDDA(minx[i], i+miny,maxx[i],i+miny);
        }
        
    }

    function linea(p1,p2,c) {
        return lineaDDA(p1.x,p1.y,p2.x,p2.y,c);
    }

    function punto(x,y,c) {
        this.x = x;
        this.y = y;
        this.c = c;
    }

    function cuad(p1,p2,p3,p4) {
        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
        this.p4 = p4;
    }

    function objeto(t,e,tipo) {
        this.t = t;
        this.e = e;
        this.tipo = tipo;
    }

    function defi(o) {
        this.o = o;
    }

    function prod_matriz(a,b) {
        var c = [];
        for(i=0;i<=2;i++) {
            c[i] = [];
            for(j=0;j<=2;j++){
                c[i][j]=0;
                for(k=0;k<=2;k++)
                   c[i][j] += a[i][k]*b[k][j];
            }
        }
        return c;
    }

    function multVM(v,t) {
        var c = [];
        for(i=0;i<=2;i++) {
            c[i] = 0;
            for(k=0;k<=2;k++)
               c[i] += v[k]*t[k][i];
        }
        return c;
    }

    cuad.prototype.transformar = function(t) {
        var v = multVM([this.p1.x,this.p1.y,1.0],t);
        this.p1.x = v[0];
        this.p1.y = v[1];
        v = multVM([this.p2.x,this.p2.y,1.0],t);
        this.p2.x = v[0];
        this.p2.y = v[1];
        v = multVM([this.p3.x,this.p3.y,1.0],t);
        this.p3.x = v[0];
        this.p3.y = v[1];
        v = multVM([this.p4.x,this.p4.y,1.0],t);
        this.p4.x = v[0];
        this.p4.y = v[1];
    }

    cuad.prototype.graf_cuad = function(o,at,c) {
        var t = o.t;
        var t1 = prod_matriz(t,at);
        this.transformar(t1);
        linea(this.p1,this.p2,c);
        linea(this.p2,this.p3,c);
        linea(this.p3,this.p4,c);
        linea(this.p4,this.p1,c);
    }

    objeto.prototype.graf_obj = function(t,c) {
        if(this.tipo == 'cuad') {
            this.e.graf_cuad(this,t,c);
        }
        else {
            var t1 = prod_matriz(this.t,t);
            for(var i = 0; i < this.e.length; i++) {
                this.e[i].graf_obj(t1,c);
            }
        }
    }
 
    function webGLStart() {
        // se obtiene el objeto canvas del codigo html (como un objeto javascript)
        var canvas = document.getElementById("canvas");

        // inicializaciones
        initGL(canvas);
        initShaders();
        initVariables();
        putpixel(0,0);
        putpixel(2,2);
        putpixel(1,1);
        lineaDDA(0,0,100,100);
        lineaBresenham(200,200,100,100);

        var id = [[1,0,0],[0,1,0],[0,0,1]];

        var c = new cuad(new punto(-10,0),new punto(100,0),new punto(100,100), new punto(0,100));
        var o = new objeto(id,c,'cuad');
        c.graf_cuad(o,id,[0.3,0.5,0.6]);

        var c2 = new cuad(new punto(-30,0),new punto(0,0),new punto(0,-30), new punto(-30,-30));
        var c3 = new cuad(new punto(-100,0),new punto(0,0),new punto(0,-100), new punto(-100,-100));
        var o2 = new objeto(id,[new objeto(id,c2,'cuad'),new objeto(id,c3,'cuad')],'lista');
        o2.graf_obj(id,[0.8,0.5,0.2]);
 
        initBuffers();
        dibujarEscena();
    }
 
 </script> 
</head> 
 
 
<body onload="webGLStart();"> 
    <canvas id="canvas" width="500" height="500"></canvas>  
</body> 
 
</html> 
